<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Práctica 1: Señales en tiempo continuo.</title>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] },
  TeX: { equationNumbers: { autoNumber: 'all' } }
});
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<style>
body > * {
  max-width: 42em;
}
body {
  font-family: "Roboto Condensed", sans-serif;
  padding-left: 7.5em;
  padding-right: 7.5em;
}
pre, code {
  max-width: 50em;
  font-family: monospace;
}
pre.oct-code {
  border: 1px solid Grey;
  padding: 5px;
}
pre.oct-code-output {
  margin-left: 2em;
}
span.comment {
  color: ForestGreen;
}
span.keyword {
  color: Blue;
}
span.string {
  color: DarkOrchid;
}
footer {
  margin-top: 2em;
  font-size: 80%;
}
a, a:visited {
  color: Blue;
}
h2 {
  font-family: "Roboto Condensed", serif;
  margin-top: 1.5em;
}
h2 a, h2 a:visited {
  color: Black;
}
</style>

</head>
<body>
<h1>Práctica 1: Señales en tiempo continuo.</h1>

<p><b>Integrantes:</b></p>

<ul>
<li>Arellano Paz Angel Ulises</li>
<li>Cardoso Arias Javier</li>
<li>Gachuz Hernández Karla Denisse</li>
<li>García Arteaga Alejandro</li>
<li>López Galván José Rodolfo</li>
</ul>

<p><b>Objetivos:</b></p>

<ul>
<li>Manipulación básica de MATLAB</li>
<li>Gráficas de señales reales y complejas continuas</li>
<li>Transformación de señales continuas (escalamientos y traslaciones)</li>
<li>Calculo de energía y potencia de señales continuas</li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#node1"> 1) Working with functions.</a></li>
<li><a href="#node2">2) Resolución del problema 1.2-2</a></li>
<li><a href="#node3">3) Resolución del problema 1.11-1</a></li>
<li><a href="#node4">4) Contruscciòn de la gráfica.</a></li>
</ul>
<h2><a id="node1"> 1) Working with functions.</a></h2>
<p>Working with functions is fundamental to signals and systems applications. MATLAB provides several methods of defining and evaluating functions. An understanding and proficient use of these methods are therefore necessary and beneficial.</p>

<p><b>11.1-1 Anonymous functions.</b></p>

<p>Many simple functions are most conveniently represented by using MATLAB anonymous functions. An anonymous function provides a symbolic representation of a function defined in terms of MATLAB operators, functions, or other anonymous functions. For example, consider defining the exponentially damped sinusoid $f (t) = e −t cos(2π t)$.</p>

<pre class="oct-code">f = @(t) exp(-t).*cos(2*pi*t);</pre>

<p>In this context, the @ symbol identifies the expression as an anonymous function, which is assigned a name of f. Parentheses following the @ symbol are used to identify the function’s independent variables (input arguments), which in this case is the single time variable t. Input arguments, such as t, are local to the anonymous function and are not related to any workspace variables with the same names.</p>

<p>Once defined, $f (t)$ can be evaluated simply by passing the input values of interest. For example,</p>

<pre class="oct-code">t =0; f(t)</pre>

<pre class="oct-code-output">ans =  1
</pre>

<p>evaluates $f (t)$ at t = 0, confirming the expected result of unity. The same result is obtained by passing t = 0 directly.</p>

<p>Vector inputs allow the evaluation of multiple values simultaneously, Consider the task of plotting $f(t)$ over the interval $(-2 \leq t \leq 2)$. Gross function behavior is clear:  $f(t)$ should oscilate four times with a decaying envelope. Since accurate hand sketches are cumberstone, MATLAB-generated plots are an attractive alternative. As the following example illustrates, care must be taken to ensure reliable results.</p>

<p>Suppose the vector t is chosen to include onlu the integers contained in $(-2 \leq t \leq 2)$, namely, [−2, −1, 0, 1, 2].</p>

<pre class="oct-code">t = (-2:2);</pre>

<p>This vector input is evaluated from a vector output.</p>

<pre class="oct-code">f(t)</pre>

<pre class="oct-code-output">ans =
 
   7.38906   2.71828   1.00000   0.36788   0.13534
 
</pre>

<p>The plot command graphs the result, which is shown in Fig. 1.46</p>

<pre class="pre-text">&gt;&gt; plot(t,f(t));
&gt;&gt; xlabel(’t’); ylabel(’f(t)’); grid;</pre>

<p>Grid lines, added by using the grid command, aid feature identification. Unfortunately, the
plot does not illustrate the expected oscillatory behavior. More points are required to adequately
represent f (t).
The question, then, is how many points is enough? † If too few points are chosen, information
is lost. If too many points are chosen, memory and time are wasted. A balance is needed. For
oscillatory functions, plotting 20 to 200 points per oscillation is normally adequate. For the present
case, t is chosen to give 100 points per oscillation.</p>

<pre class="oct-code">plot(t, f(t));
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'f(t)'</span>);
grid;</pre>
<img src="prueba-1.png" alt="prueba-1.png">
<p><b>Figure 1.46</b> $f(t) = e^{-t}cos(2\pi t)$ for $t = (-2::2)$.</p>

<pre class="oct-code">t1 = (-2:0.01:2);
plot(t1, f(t1));
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'f(t)'</span>);
grid;</pre>
<img src="prueba-2.png" alt="prueba-2.png">
<p><b>Figure 1.47</b> $f(t) = e^{-t}cos(2\pi t)$ for $t = (-2:0.01:2)$.</p>

<p><b>1.11-2 Relational Operators and the Unit Step Function.</b></p>

<p>The unit step function $u(t)$ arises naturally in many practical situations. For example, a unit step can
model the act of turning on a system. With the help of relational operators, anonymous functions
can represent the unit step function.
In MATLAB, a relational operator compares two items. If the comparison is true, a logical true
(1) is returned. If the comparison is false, a logical false (0) is returned. Sometimes called indicator
functions, relational operators indicates whether a condition is true. Six relational operators are
available: &lt;, &gt;, &lt;=, &gt;=, ==, and ~=.
  The unit step function is readily defined using the &gt;= relational operator.</p>

<pre class="oct-code">u = @(t) 1.0.*(t&gt;=0);</pre>

<p>Any function with a jump discontinuity, such as the unit step, is difficult to plot. Consider plotting
$u(t)$ by using $t = (-2:2)$.</p>

<pre class="oct-code">t = (-2:2);
plot(t, u(t));
xlabel (<span class="string">'t'</span>);
ylabel(<span class="string">'u(t)'</span>);</pre>
<img src="prueba-3.png" alt="prueba-3.png">
<p><b>Figure 1.48</b> $u(t)$ for $t = (-2:2)$.ous functions, we could
have used our previously defined unit step anonymous function to define p(t) as p = @(t)</p>

<p>Two significant problems are apparent in the resulting plot, shown in Fig. 1.48. First,
MATLAB automatically scales plot axes to tightly bound the data. In this case, this normally
desirable feature obscures most of the plot. Second, MATLAB connects plot data with lines,
making a true jump discontinuity difficult to achieve. The coarse resolution of vector t emphasizes
the effect by showing an erroneous sloping line between t = −1 and t = 0.
The first problem is corrected by vertically enlarging the bounding box with the axis
command. The second problem is reduced, but not eliminated, by adding points to vector t.</p>

<pre class="oct-code">t = (-2:0.01:2);
plot(t, u(t));
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'u(t)'</span>);
axis([-2 2 -0.1 1.1]);</pre>
<img src="prueba-4.png" alt="prueba-4.png">
<p><b>Figure 1.48</b> $u(t)$ for $t = (-2:0.01:2)$.</p>

<p>The four-element vector argument of axis specifies x axis minimum, x axis maximum, y axis
minimum, and y axis maximum, respectively. The improved results are shown in Fig. 1.49.
Relational operators can be combined using logical AND, logical OR, and logical negation: &amp;,
|, and ~, respectively. For example, (t&gt;0) &amp; (t&lt;1) and ~((t&lt;=0) $|$ (t&gt;=1)) both test if 0 &lt; t &lt; 1.
To demonstrate, consider defining and plotting the unit pulse p(t) = u(t) − u(t − 1), as shown in
Fig. 1.50:</p>

<pre class="oct-code">p =@(t) 1.0.*((t&gt;=0)&amp;(t&lt;1));
t = (-1:0.01:2);
plot(t, p(t));
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'p(t) = u(t) - u(t-1)'</span>);
axis([-1 2 -0.1 1.1]);
title(<span class="string">'*Figure 1.50* $p(t) = u(t) − u(t − 1) over (−1 ≤ t ≤ 2)$.'</span>);</pre>
<img src="prueba-5.png" alt="prueba-5.png">
<p>Since anonymous functions can be constructed using other anonymous functions, we could
have used our previously defined unit step anonymous function to define p(t) as p = @(t)
u(t)-u(t-1);.</p>

<p>For scalar operands, MATLAB also supports two short-circuit logical constructs. A
short-circuit logical AND is performed by using &amp;&amp;, and a short-circuit logical OR is performed by
using <code></code>. Short-circuit logical operators are often more efficient than traditional logical operators
because they test the second portion of the expression only when necessary. That is, when scalar
expression A is found false in (A&amp;&amp;B), scalar expression B is not evaluated, since a false result
is already guaranteed. Similarly, scalar expression B is not evaluated when scalar expression A is
found true in (A||B), since a true result is already guaranteed.</p>

<p><b>1.11-3 Visualizing Operations on the Independent Variable</b></p>

<p>Two operations on a function’s independent variable are commonly encountered: shifting and
scaling. Anonymous functions are well suited to investigate both operations.
Consider $g(t) = f (t)u(t) = e −t cos (2π t)u(t)$, a causal version of $f(t)$. MATLAB easily
multiplies anonymous functions. Thus, we create $g(t)$ by multiplying our anonymous functions
for $f(t)$ and $u(t)$.</p>

<pre class="oct-code">g = @(t) f(t).*u(t);</pre>

<p>A combined shifting and scaling operation is represented by $g(at + b)$, where a and b are
arbitrary real constants. As an example, consider plotting $g(2t + 1)$ over $(−2 ≤ t ≤ 2)$. With a = 2,
the function is compressed by a factor of 2, resulting in twice the oscillations per unit t. Adding
the condition b &gt; 0 shifts the waveform to the left. Given anonymous function g, an accurate plot
is nearly trivial to obtain.</p>

<pre class="oct-code">t = (-2:0.01:2);
plot(t,g(2*t+1)); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'g(2t+1)'</span>); grid;
title(<span class="string">'*Figure 1.51* $g(2t + 1) over (−2 ≤ t ≤ 2)$.'</span>);</pre>
<img src="prueba-6.png" alt="prueba-6.png">
<pre class="oct-code">plot(t,g(-t+1)); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'g(-t+1)'</span>); grid;
title(<span class="string">'*Figure 1.52* $g(−t + 1)$ over $(−2 ≤ t ≤ 2)$'</span>);</pre>
<img src="prueba-7.png" alt="prueba-7.png">
<pre class="oct-code">plot(t,g(2*t+1)+g(-t+1)); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'h(t)'</span>); grid;
title(<span class="string">'*Figure 1.53* $h(t) = g(2t + 1) + g(−t + 1)$ over $(−2 ≤ t ≤ 2)$.'</span>);</pre>
<img src="prueba-8.png" alt="prueba-8.png">
<p>Figure 1.51 confirms the expected waveform compression and left shift. As a final check, realize
that function $g(·)$ turns on when the input argument is zero. Therefore, $g(2t + 1)$ should turn on
when 2t + 1 = 0 or at t = −0.5, a fact again confirmed by Fig. 1.51.</p>
<h2><a id="node2">2) Resolución del problema 1.2-2</a></h2>
<p>For the signal x(t) illustrated in Fig. P1.2-2, sketch</p>

<p>A) $x(t-4)$</p>

<p>B) $x(t/1.5)$</p>

<p>C) $x(-t)$</p>

<p>D) $x(2t-4)$</p>

<p>E) $x(2-t)$</p>

<pre class="oct-code">u = @(t) 1.0.*(t&gt;=0);

u1= @(t) 1.0.*((t&gt;=-4)&amp;(t&lt;0));

u2=@(t) 1.0.*((t&gt;=0)&amp;(t&lt;=2));

f=@(t) (-t.*u1(t)) + (t.*u2(t));

t = (-20:0.01:20);

plot(t,f(t))

axis([-5 5 -1 5]);

title(<span class="string">'Fig. P1.2-2'</span>);

xlabel(<span class="string">'t'</span>);

ylabel(<span class="string">'x(t)'</span>);</pre>
<img src="prueba-9.png" alt="prueba-9.png">
<p><b>A)</b> $x(t-4)$</p>

<pre class="oct-code">x1=@(t) f(t-4);

plot(t,x1(t));

axis([-1 9 -1 5]);

title(<span class="string">'Inciso a'</span>);

xlabel(<span class="string">'t'</span>);

ylabel(<span class="string">'x(t-4)'</span>);</pre>
<img src="prueba-10.png" alt="prueba-10.png">
<p><b>B)</b> $x(t/1.5)$</p>

<pre class="oct-code">x2=@(t) f(t/1.5);

plot(t,x2(t));

axis([-8 5 -1 5]);

title(<span class="string">'Inciso b'</span>);

xlabel(<span class="string">'t'</span>);

ylabel(<span class="string">'x(t/1.5)'</span>);</pre>
<img src="prueba-11.png" alt="prueba-11.png">
<p><b>C)</b> $x(-t)$</p>

<pre class="oct-code">x3=@(t) f(-t);

plot(t,x3(t));

axis([-5 5 -1 5]);

title(<span class="string">'Inciso c'</span>);

xlabel(<span class="string">'t'</span>);

ylabel(<span class="string">'x(-t)'</span>);</pre>
<img src="prueba-12.png" alt="prueba-12.png">
<p><b>D)</b> $x(2t-4)$</p>

<pre class="oct-code">x4=@(t) f(2.*t - 4);

plot(t,x4(t));

axis([-5 5 -1 5]);

title(<span class="string">'Inciso d'</span>);

xlabel(<span class="string">'t'</span>);

ylabel(<span class="string">'x(2t-4)'</span>);</pre>
<img src="prueba-13.png" alt="prueba-13.png">
<p><b>E)</b> $x(2t-4)$</p>

<pre class="oct-code">x5=@(t) f(2 - t);

plot(t,x5(t));

axis([-1 8 -1 5]);

title(<span class="string">'Inciso e'</span>);

xlabel(<span class="string">'t'</span>);

ylabel(<span class="string">'x(2-t)'</span>);


t=(-3*pi:0.001:3*pi);</pre>
<img src="prueba-14.png" alt="prueba-14.png">
<p>$X(t)=2^t*cos(2pit)$</p>

<p>$X_{impar(t)}=1/2(x(t)-x(-t))$</p>

<p>$X_{impar(t)}=(2^(-t-1))*cos(2pit)-(2^(t-1))*cos(-2pit)$</p>
<h2><a id="node3">3) Resolución del problema 1.11-1</a></h2>
<pre class="oct-code"><span class="keyword">for</span> i=1:length(t)
<span class="keyword">if</span> t(i)&lt;=-pi
R(i)=-(2.^(t(i)-1)).*cos(-2*pi*t(i));
<span class="keyword">elseif</span> t(i)&gt;=pi
R(i)=(2.^(-t(i)-1)).*cos(2*pi*t(i));
<span class="keyword">else</span>
R(i)=0;
<span class="keyword">end</span>
<span class="keyword">end</span>

plot(t,R);
ylabel(<span class="string">'Ximpar(t)'</span>);
xlabel(<span class="string">'t'</span>);
title(<span class="string">'Ejercicio 1.11-1'</span>);
grid on;</pre>
<img src="prueba-15.png" alt="prueba-15.png"><h2><a id="node4">4) Contruscciòn de la gráfica.</a></h2>
<p>Construye la grafica de</p>

<p>$$x(t) = \sum_{k=1}^{10} cos(2\pi k t)$$</p>

<p>para cuatro rangos (figura 2x2). Los ejes deben mostrarse en el origen además de la edición de su preferencia.
Procedimiento:</p>

<pre class="oct-code">clf;
subplot(2,2,1);
y=0;
t=linspace(-4*pi,-2*pi,1000);
<span class="keyword">for</span> k=1:10

x=cos(2*pi*k*t);
y=y+x;
<span class="keyword">end</span>
plot(t,y);
grid on;
ax = gca;
xlabel(<span class="string">'Dominio t'</span>);
ylabel(<span class="string">'x(t)'</span>);
title(<span class="string">'Gráfica rango -4pi&lt;=t&lt;=-2pi '</span>);



subplot(2,2,2);
y=0;
t=linspace(-2*pi,0,1000);
<span class="keyword">for</span> k=1:10

x=cos(2*pi*k*t);
y=y+x;
<span class="keyword">end</span>
plot(t,y);
grid on;
ax = gca;
xlabel(<span class="string">'Dominio t'</span>);
ylabel(<span class="string">'x(t)'</span>);

title(<span class="string">'Gráfica rango -2pi&lt;=t&lt;=0 '</span>);



subplot(2,2,3);
y=0;
t=linspace(0,2*pi,1000);
<span class="keyword">for</span> k=1:10

x=cos(2*pi*k*t);
y=y+x;
<span class="keyword">end</span>
plot(t,y);
grid on;
ax = gca;
xlabel(<span class="string">'Dominio t'</span>);
ylabel(<span class="string">'x(t)'</span>);
title(<span class="string">'Gráfica rango 0&lt;=t&lt;=2pi '</span>);



subplot(2,2,4);
y=0;
t=linspace(2*pi,4*pi,1000);
<span class="keyword">for</span> k=1:10

x=cos(2*pi*k*t);
y=y+x;
<span class="keyword">end</span>
plot(t,y);
grid on;
ax = gca;
xlabel(<span class="string">'Dominio t'</span>);
ylabel(<span class="string">'x(t)'</span>);
title(<span class="string">'Gráfica rango 2pi&lt;=t&lt;42pi '</span>);</pre>
<img src="prueba-16.png" alt="prueba-16.png">
<footer>
<hr>
<a href="https://www.octave.org">Published with GNU Octave 5.2.0</a>
</footer>
<!--
##### SOURCE BEGIN #####
%% Práctica 1: Señales en tiempo continuo.
%
% *Integrantes:*
%
% * Arellano Paz Angel Ulises
% * Cardoso Arias Javier
% * Gachuz Hernández Karla Denisse
% * García Arteaga Alejandro
% * López Galván José Rodolfo
%
% *Objetivos:*
%
% * Manipulación básica de MATLAB
% * Gráficas de señales reales y complejas continuas
% * Transformación de señales continuas (escalamientos y traslaciones)
% * Calculo de energía y potencia de señales continuas

%%



%%  1) Working with functions.
%
% Working with functions is fundamental to signals and systems applications. MATLAB provides several methods of defining and evaluating functions. An understanding and proficient use of these methods are therefore necessary and beneficial.

%%
% *11.1-1 Anonymous functions.*
%
% Many simple functions are most conveniently represented by using MATLAB anonymous functions. An anonymous function provides a symbolic representation of a function defined in terms of MATLAB operators, functions, or other anonymous functions. For example, consider defining the exponentially damped sinusoid $f (t) = e −t cos(2π t)$.

f = @(t) exp(-t).*cos(2*pi*t);

%%
% In this context, the @ symbol identifies the expression as an anonymous function, which is assigned a name of f. Parentheses following the @ symbol are used to identify the function’s independent variables (input arguments), which in this case is the single time variable t. Input arguments, such as t, are local to the anonymous function and are not related to any workspace variables with the same names.
%
% Once defined, $f (t)$ can be evaluated simply by passing the input values of interest. For example,

t =0; f(t)

%%
% evaluates $f (t)$ at t = 0, confirming the expected result of unity. The same result is obtained by passing t = 0 directly.

%%
% Vector inputs allow the evaluation of multiple values simultaneously, Consider the task of plotting $f(t)$ over the interval $(-2 \leq t \leq 2)$. Gross function behavior is clear:  $f(t)$ should oscilate four times with a decaying envelope. Since accurate hand sketches are cumberstone, MATLAB-generated plots are an attractive alternative. As the following example illustrates, care must be taken to ensure reliable results.
%
% Suppose the vector t is chosen to include onlu the integers contained in $(-2 \leq t \leq 2)$, namely, [−2, −1, 0, 1, 2].

t = (-2:2);

%%
% This vector input is evaluated from a vector output.

f(t)

%%
% The plot command graphs the result, which is shown in Fig. 1.46

%%
%
%  >> plot(t,f(t));
%  >> xlabel(’t’); ylabel(’f(t)’); grid;
%

%%
% Grid lines, added by using the grid command, aid feature identification. Unfortunately, the
% plot does not illustrate the expected oscillatory behavior. More points are required to adequately
% represent f (t).
% The question, then, is how many points is enough? † If too few points are chosen, information
% is lost. If too many points are chosen, memory and time are wasted. A balance is needed. For
% oscillatory functions, plotting 20 to 200 points per oscillation is normally adequate. For the present
% case, t is chosen to give 100 points per oscillation.

plot(t, f(t));
xlabel('t');
ylabel('f(t)');
grid;

%%
% *Figure 1.46* $f(t) = e^{-t}cos(2\pi t)$ for $t = (-2::2)$.

t1 = (-2:0.01:2);
plot(t1, f(t1));
xlabel('t');
ylabel('f(t)');
grid;

%%
% *Figure 1.47* $f(t) = e^{-t}cos(2\pi t)$ for $t = (-2:0.01:2)$.

%%
% *1.11-2 Relational Operators and the Unit Step Function.*
%
% The unit step function $u(t)$ arises naturally in many practical situations. For example, a unit step can
% model the act of turning on a system. With the help of relational operators, anonymous functions
% can represent the unit step function.
% In MATLAB, a relational operator compares two items. If the comparison is true, a logical true
% (1) is returned. If the comparison is false, a logical false (0) is returned. Sometimes called indicator
% functions, relational operators indicates whether a condition is true. Six relational operators are
% available: <, >, <=, >=, ==, and ~=.
%   The unit step function is readily defined using the >= relational operator.

u = @(t) 1.0.*(t>=0);

%%
% Any function with a jump discontinuity, such as the unit step, is difficult to plot. Consider plotting
% $u(t)$ by using $t = (-2:2)$.

t = (-2:2);
plot(t, u(t));
xlabel ('t');
ylabel('u(t)');

%%
% *Figure 1.48* $u(t)$ for $t = (-2:2)$.ous functions, we could
% have used our previously defined unit step anonymous function to define p(t) as p = @(t)

%%
% Two significant problems are apparent in the resulting plot, shown in Fig. 1.48. First,
% MATLAB automatically scales plot axes to tightly bound the data. In this case, this normally
% desirable feature obscures most of the plot. Second, MATLAB connects plot data with lines,
% making a true jump discontinuity difficult to achieve. The coarse resolution of vector t emphasizes
% the effect by showing an erroneous sloping line between t = −1 and t = 0.
% The first problem is corrected by vertically enlarging the bounding box with the axis
% command. The second problem is reduced, but not eliminated, by adding points to vector t.

t = (-2:0.01:2);
plot(t, u(t));
xlabel('t');
ylabel('u(t)');
axis([-2 2 -0.1 1.1]);

%%
% *Figure 1.48* $u(t)$ for $t = (-2:0.01:2)$.

%%
% The four-element vector argument of axis specifies x axis minimum, x axis maximum, y axis
% minimum, and y axis maximum, respectively. The improved results are shown in Fig. 1.49.
% Relational operators can be combined using logical AND, logical OR, and logical negation: &,
% |, and ~, respectively. For example, (t>0) & (t<1) and ~((t<=0) $|$ (t>=1)) both test if 0 < t < 1.
% To demonstrate, consider defining and plotting the unit pulse p(t) = u(t) − u(t − 1), as shown in
% Fig. 1.50:

p =@(t) 1.0.*((t>=0)&(t<1));
t = (-1:0.01:2);
plot(t, p(t));
xlabel('t');
ylabel('p(t) = u(t) - u(t-1)');
axis([-1 2 -0.1 1.1]);
title('*Figure 1.50* $p(t) = u(t) − u(t − 1) over (−1 ≤ t ≤ 2)$.');
%%
% Since anonymous functions can be constructed using other anonymous functions, we could
% have used our previously defined unit step anonymous function to define p(t) as p = @(t)
% u(t)-u(t-1);.

%%
% For scalar operands, MATLAB also supports two short-circuit logical constructs. A
% short-circuit logical AND is performed by using &&, and a short-circuit logical OR is performed by
% using ||. Short-circuit logical operators are often more efficient than traditional logical operators
% because they test the second portion of the expression only when necessary. That is, when scalar
% expression A is found false in (A&&B), scalar expression B is not evaluated, since a false result
% is already guaranteed. Similarly, scalar expression B is not evaluated when scalar expression A is
% found true in (A||B), since a true result is already guaranteed.

%%
% *1.11-3 Visualizing Operations on the Independent Variable*

%%
% Two operations on a function’s independent variable are commonly encountered: shifting and
% scaling. Anonymous functions are well suited to investigate both operations.
% Consider $g(t) = f (t)u(t) = e −t cos (2π t)u(t)$, a causal version of $f(t)$. MATLAB easily
% multiplies anonymous functions. Thus, we create $g(t)$ by multiplying our anonymous functions
% for $f(t)$ and $u(t)$.

g = @(t) f(t).*u(t);

%%
% A combined shifting and scaling operation is represented by $g(at + b)$, where a and b are
% arbitrary real constants. As an example, consider plotting $g(2t + 1)$ over $(−2 ≤ t ≤ 2)$. With a = 2,
% the function is compressed by a factor of 2, resulting in twice the oscillations per unit t. Adding
% the condition b > 0 shifts the waveform to the left. Given anonymous function g, an accurate plot
% is nearly trivial to obtain.

t = (-2:0.01:2);
plot(t,g(2*t+1)); xlabel('t'); ylabel('g(2t+1)'); grid;
title('*Figure 1.51* $g(2t + 1) over (−2 ≤ t ≤ 2)$.');

%%
%

plot(t,g(-t+1)); xlabel('t'); ylabel('g(-t+1)'); grid;
title('*Figure 1.52* $g(−t + 1)$ over $(−2 ≤ t ≤ 2)$');

%%
%

plot(t,g(2*t+1)+g(-t+1)); xlabel('t'); ylabel('h(t)'); grid;
title('*Figure 1.53* $h(t) = g(2t + 1) + g(−t + 1)$ over $(−2 ≤ t ≤ 2)$.');

%%
% Figure 1.51 confirms the expected waveform compression and left shift. As a final check, realize
% that function $g(·)$ turns on when the input argument is zero. Therefore, $g(2t + 1)$ should turn on
% when 2t + 1 = 0 or at t = −0.5, a fact again confirmed by Fig. 1.51.

%% 2) Resolución del problema 1.2-2

%%
% For the signal x(t) illustrated in Fig. P1.2-2, sketch
%%
% A) $x(t-4)$
%%
% B) $x(t/1.5)$
%%
% C) $x(-t)$
%%
% D) $x(2t-4)$
%%
% E) $x(2-t)$


u = @(t) 1.0.*(t>=0);

u1= @(t) 1.0.*((t>=-4)&(t<0));

u2=@(t) 1.0.*((t>=0)&(t<=2));

f=@(t) (-t.*u1(t)) + (t.*u2(t));

t = (-20:0.01:20);

plot(t,f(t))

axis([-5 5 -1 5]);

title('Fig. P1.2-2');

xlabel('t');

ylabel('x(t)');

%%
% *A)* $x(t-4)$



x1=@(t) f(t-4);

plot(t,x1(t));

axis([-1 9 -1 5]);

title('Inciso a');

xlabel('t');

ylabel('x(t-4)');

%%
% *B)* $x(t/1.5)$



x2=@(t) f(t/1.5);

plot(t,x2(t));

axis([-8 5 -1 5]);

title('Inciso b');

xlabel('t');

ylabel('x(t/1.5)');

%%
% *C)* $x(-t)$




x3=@(t) f(-t);

plot(t,x3(t));

axis([-5 5 -1 5]);

title('Inciso c');

xlabel('t');

ylabel('x(-t)');

%%
% *D)* $x(2t-4)$




x4=@(t) f(2.*t - 4);

plot(t,x4(t));

axis([-5 5 -1 5]);

title('Inciso d');

xlabel('t');

ylabel('x(2t-4)');

%%
% *E)* $x(2t-4)$




x5=@(t) f(2 - t);

plot(t,x5(t));

axis([-1 8 -1 5]);

title('Inciso e');

xlabel('t');

ylabel('x(2-t)');


t=(-3*pi:0.001:3*pi);

%%
% $X(t)=2^t*cos(2pit)$
%%
% $X_{impar(t)}=1/2(x(t)-x(-t))$
%%
% $X_{impar(t)}=(2^(-t-1))*cos(2pit)-(2^(t-1))*cos(-2pit)$


%% 3) Resolución del problema 1.11-1
%

for i=1:length(t)
if t(i)<=-pi
R(i)=-(2.^(t(i)-1)).*cos(-2*pi*t(i));
elseif t(i)>=pi
R(i)=(2.^(-t(i)-1)).*cos(2*pi*t(i));
else
R(i)=0;
end
end

plot(t,R);
ylabel('Ximpar(t)');
xlabel('t');
title('Ejercicio 1.11-1');
grid on;

%% 4) Contruscciòn de la gráfica.
%
% Construye la grafica de

%%
% $$x(t) = \sum_{k=1}^{10} cos(2\pi k t)$$
%
% para cuatro rangos (figura 2x2). Los ejes deben mostrarse en el origen además de la edición de su preferencia.
% Procedimiento:
%

clf;
subplot(2,2,1);
y=0;
t=linspace(-4*pi,-2*pi,1000);
for k=1:10

x=cos(2*pi*k*t);
y=y+x;
end
plot(t,y);
grid on;
ax = gca;
xlabel('Dominio t');
ylabel('x(t)');
title('Gráfica rango -4pi<=t<=-2pi ');



subplot(2,2,2);
y=0;
t=linspace(-2*pi,0,1000);
for k=1:10

x=cos(2*pi*k*t);
y=y+x;
end
plot(t,y);
grid on;
ax = gca;
xlabel('Dominio t');
ylabel('x(t)');

title('Gráfica rango -2pi<=t<=0 ');



subplot(2,2,3);
y=0;
t=linspace(0,2*pi,1000);
for k=1:10

x=cos(2*pi*k*t);
y=y+x;
end
plot(t,y);
grid on;
ax = gca;
xlabel('Dominio t');
ylabel('x(t)');
title('Gráfica rango 0<=t<=2pi ');



subplot(2,2,4);
y=0;
t=linspace(2*pi,4*pi,1000);
for k=1:10

x=cos(2*pi*k*t);
y=y+x;
end
plot(t,y);
grid on;
ax = gca;
xlabel('Dominio t');
ylabel('x(t)');
title('Gráfica rango 2pi<=t<42pi ');
##### SOURCE END #####
-->
</body>
</html>
